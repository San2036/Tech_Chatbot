import os
import json
import random
import re
import streamlit as st
import numpy as np
import pandas as pd
from datetime import datetime
from sklearn.feature_extraction.text import TfidfVectorizer, ENGLISH_STOP_WORDS
from sklearn.metrics.pairwise import cosine_similarity
import requests

st.set_page_config(page_title="Tech Support Chatbot", page_icon="💻")

# --- Preprocessing ---
def preprocess(text):
    tokens = re.findall(r'\b\w+\b', text.lower())
    filtered = [word for word in tokens if word not in ENGLISH_STOP_WORDS]
    return " ".join(filtered)

# --- Load intents ---
file_path = "tech_intents.json"
intents = []
try:
    with open(file_path, "r", encoding="utf-8") as file:
        data = json.load(file)
        if "intents" in data:
            intents = data["intents"]
except Exception as e:
    st.error(f"Error loading intents: {e}")

# --- Preprocess training data ---
patterns, responses, tags, processed_patterns = [], [], [], []
if intents:
    for intent in intents:
        for pattern in intent["patterns"]:
            patterns.append(pattern)
            processed_patterns.append(preprocess(pattern))
            tags.append(intent["tag"])
            responses.append(random.choice(intent["responses"] if intent["responses"] else [""]))

# --- Train TF-IDF model ---
vectorizer = TfidfVectorizer()
x_train = vectorizer.fit_transform(processed_patterns) if processed_patterns else None

# --- Log chat to CSV ---
def log_chat(user_input, bot_response):
    log_file = "tech_chat_log.csv"
    entry = {
        "Timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "User Input": user_input,
        "Bot Response": bot_response
    }
    if os.path.exists(log_file):
        df = pd.read_csv(log_file)
        df = pd.concat([df, pd.DataFrame([entry])], ignore_index=True)
    else:
        df = pd.DataFrame([entry])
    df.to_csv(log_file, index=False)

# --- Dynamic API fetch or fallback ---
def fetch_dynamic_response(query):
    try:
        # Replace this with your actual API endpoint
        api_url = "https://api.example.com/query"
        params = {"q": query}
        headers = {"Accept": "application/json"}
        response = requests.get(api_url, params=params, headers=headers, timeout=5)

        if response.status_code == 200:
            result = response.json()
            return result.get("answer", "Sorry, I couldn't find a suitable answer.")
        else:
            return "Our support API didn't respond correctly. Try again later."
    except Exception:
        # Simulated fallback answers
        fallback_answers = {
            "software": "For coding, VS Code is highly recommended. For antivirus, try Bitdefender or Kaspersky.",
            "slow": "If your PC is still slow, try checking startup programs and background processes in Task Manager.",
            "crashes": "Frequent crashes may indicate RAM or driver issues. Run a memory diagnostic test.",
            "help": "Try specifying the problem in detail — is it hardware or software related?"
        }
        for keyword in fallback_answers:
            if keyword in query.lower():
                return fallback_answers[keyword]
        return "I'm still learning! Please check support forums or describe the problem more clearly."

# --- Chatbot logic ---
def chatbot(input_text):
    if x_train is None:
        return "Sorry, I can't process your query right now."

    input_vec = vectorizer.transform([preprocess(input_text)])
    similarity = cosine_similarity(input_vec, x_train).flatten()
    best_index = np.argmax(similarity)
    confidence = similarity[best_index]

    if confidence < 0.3:
        return "I'm not sure I understand that. Can you rephrase?"

    matched_tag = tags[best_index]
    matched_intent = next((intent for intent in intents if intent["tag"] == matched_tag), None)

    if matched_intent:
        if matched_intent.get("dynamic", False):
            dynamic_response = fetch_dynamic_response(input_text)
            if not dynamic_response or "couldn't fetch" in dynamic_response:
                return random.choice(matched_intent["responses"]) if matched_intent["responses"] else \
                    "Still searching for an answer. Please try rephrasing."
            return dynamic_response
        return random.choice(matched_intent["responses"])

    return "I understand your question, but I don't have a good answer yet."

# --- Streamlit UI ---
def main():
    st.title("💻 Tech Support Chatbot")

    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []
    if "page" not in st.session_state:
        st.session_state.page = "home"
    if "clear_flag" not in st.session_state:
        st.session_state.clear_flag = False

    # --- Sidebar ---
    st.sidebar.image("https://cdn-icons-png.flaticon.com/512/4712/4712027.png", width=150)
    if st.sidebar.button("🧹 Clear Chat History"):
        st.session_state.chat_history = []
        if os.path.exists("tech_chat_log.csv"):
            os.remove("tech_chat_log.csv")
        st.session_state.clear_flag = True
        st.success("Chat history cleared!")

    # --- Navigation ---
    st.subheader("🏠 Home Page")
    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("💬 Chat"):
            st.session_state.page = "chat"
    with col2:
        if st.button("🕘 Conversation History"):
            st.session_state.page = "history"
    with col3:
        if st.button("ℹ️ About"):
            st.session_state.page = "about"

    # --- Pages ---
    if st.session_state.page == "chat":
        st.subheader("💬 Ask Your Tech Questions")

        for msg in st.session_state.chat_history:
            with st.chat_message(msg["role"]):
                st.write(msg["text"])

        user_input = st.chat_input("Type your question here...")
        if user_input:
            st.session_state.chat_history.append({"role": "user", "text": user_input})
            with st.chat_message("user"):
                st.write(user_input)

            bot_reply = chatbot(user_input)
            st.session_state.chat_history.append({"role": "assistant", "text": bot_reply})
            with st.chat_message("assistant"):
                st.write(bot_reply)

            log_chat(user_input, bot_reply)

    elif st.session_state.page == "history":
        st.subheader("🕘 Past Conversations")

        if os.path.exists("tech_chat_log.csv"):
            chat_df = pd.read_csv("tech_chat_log.csv")
            search_term = st.text_input("Search conversation:")

            filtered_df = chat_df[chat_df.apply(
                lambda row: search_term.lower() in str(row["User Input"]).lower() or
                            search_term.lower() in str(row["Bot Response"]).lower(),
                axis=1
            )]

            for _, row in filtered_df.iterrows():
                st.markdown(f"**User:** {row['User Input']}")
                st.markdown(f"**Bot:** {row['Bot Response']}")
                st.markdown("---")
        else:
            st.info("No past conversations found.")

    elif st.session_state.page == "about":
        st.subheader("ℹ️ About This Chatbot")
        st.write("""
        🤖 This is a smart tech support chatbot built using:
        - **Streamlit** for the UI  
        - **Scikit-learn** for TF-IDF + cosine similarity  
        - **Dynamic Answering** via custom API or fallback logic  
        
        💡 You can extend this bot by adding more intents to `tech_intents.json`.
        """)

if __name__ == "__main__":
    main()
